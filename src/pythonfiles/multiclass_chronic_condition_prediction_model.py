# -*- coding: utf-8 -*-
"""Multi-Label Chronic Condition Prediction Model (One-vs-the-rest (OvR))

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lOOatg8_G7afW7jl_EgSQ7mun8ZJpIrz

# **Chronic Health Prediction**
"""

import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

encoding = 'latin1'

data = pd.read_csv('/content/drive/MyDrive/BRFSS Project/Reduced_Dataset.csv', encoding=encoding, error_bad_lines=False)

df = data.copy()

df

"""**Dropping rows with less common responses**"""

# Iterate through columns with datatype 'object'
for column in df.select_dtypes(include='object').columns:
    # Count the occurrences of each unique value in the column
    value_counts = df[column].value_counts()

    # Get the unique values that occur less than 20 times
    values_to_drop = value_counts[value_counts < 50].index

    # Drop the rows where the column value is in values_to_drop
    df = df[~df[column].isin(values_to_drop)]

# Reset the index after dropping rows
df = df.reset_index(drop=True)

df

"""**Converting columns containing numeric values to int/float**"""

# Function to check if a value is numeric
def is_numeric(value):
    try:
        float(value)
        return True
    except ValueError:
        return False

# Convert object-type columns to int or float based on numeric content in at least one row
for column in df.select_dtypes(include='object').columns:
    # Check if any row in the column has purely numeric values
    if any(df[column].apply(is_numeric)):
        # Convert to float
        df[column] = pd.to_numeric(df[column], errors='coerce')

        # Convert to int if there are no decimal values, otherwise to float
        df[column] = df[column].astype(int) if all(pd.notna(value) and value.is_integer() for value in df[column]) else df[column].astype(float)

# datatype of all the columns
for column in df.columns:
    print(f"{column}: {df[column].dtypes}")

df

df.rename(columns={
    'cvdinfr4': 'Heart Attack',
    'cvdcrhd4': 'Angina Or Coronary Heart Disease',
    'cvdstrk3': 'Stroke',
}, inplace=True)

df

# Display the data types of each column before conversion
print("Before Conversion:")
print(df.dtypes)

# Convert columns with 'object' data type to 'categorical'
df = df.astype({col: 'category' for col in df.select_dtypes(include='object').columns})

# Display the data types of each column after conversion
print("\nAfter Conversion:")
print(df.dtypes)

df

# List of columns
columns_to_check = ['bphigh4', 'toldhi2', 'chcocncr', 'havarth3', 'addepev2', 'employ1', 'weight2', 'height3', 'renthom1', 'qlactlm2', 'diabete3', 'smoke100', 'asthma3', 'alcday5', 'sex']

# Check data types
data_types = df[columns_to_check].dtypes

# Display data types
print("Data Types:")
print(data_types)

# Display unique values in non-numeric columns
non_numeric_columns = df[columns_to_check].select_dtypes(exclude=['number']).columns
for column in non_numeric_columns:
    unique_values = df[column].unique()
    print(f"\nUnique values in {column}:")
    print(unique_values)

print(df.dtypes)

pip install -U scikit-learn joblib

"""# **Multi-Label Chronic Condition Prediction Model**"""

import joblib
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import warnings
import category_encoders as ce

# Ignore convergence warnings
warnings.filterwarnings("ignore", category=UserWarning)

# Assume df is your DataFrame with relevant columns

# List of chronic conditions
chronic_conditions = ['Heart Attack', 'Angina Or Coronary Heart Disease', 'Stroke']

# Selected features
selected_features_chronic_conditions = ['bphigh4', 'toldhi2', 'chcocncr', 'havarth3', 'addepev2', 'employ1', 'weight2', 'height3', 'renthom1', 'qlactlm2', 'diabete3', 'smoke100', 'asthma3', 'alcday5', 'sex']

# Create a dictionary to store trained models
models = {}

for condition in chronic_conditions:
    # Extract selected features and target variable
    X = df[selected_features_chronic_conditions].copy()  # Make a copy to avoid modifying the original DataFrame
    y = df[condition]

    # Convert categorical columns to 'category' data type
    categorical_columns = X.select_dtypes(include='category').columns
    X[categorical_columns] = X[categorical_columns].astype('category')

    # Split the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Apply Ordinal Encoding to categorical columns
    encoder = ce.OrdinalEncoder(cols=categorical_columns)
    X_train_encoded = encoder.fit_transform(X_train, y_train)
    X_test_encoded = encoder.transform(X_test)

    # Train Random Forest model
    model = RandomForestClassifier(random_state=42)
    model.fit(X_train_encoded, y_train)

    # Save the trained model
    model_filename = f'{condition.lower().replace(" ", "_")}_model.pkl'
    joblib.dump(model, model_filename)
    models[condition] = model_filename

    # Make predictions
    y_pred = model.predict(X_test_encoded)

    # Evaluate the model
    accuracy = accuracy_score(y_test, y_pred)
    classification_rep = classification_report(y_test, y_pred)
    confusion_mat = confusion_matrix(y_test, y_pred)

    print(f"Results for {condition} using selected features:")
    print(f"Accuracy: {accuracy}")
    print("Confusion Matrix:")
    print(confusion_mat)
    print("Classification Report:")
    print(classification_rep)
    print("\n")

import pickle

# Save the trained model with pickle
with open(model_filename, 'wb') as file:
    pickle.dump(model, file)

# Save the trained OrdinalEncoder
encoder_filename = 'ordinal_encoder.pkl'
joblib.dump(encoder, encoder_filename)

"""# **Model Testing**

**Sample Input 1**
"""

# Load the saved OrdinalEncoder
encoder_filename = 'ordinal_encoder.pkl'
ordinal_encoder = joblib.load(encoder_filename)

# Prepare new input data
new_data = pd.DataFrame({
    'bphigh4': ['No'],
    'toldhi2': ['No'],
    'chcocncr': ['No'],
    'havarth3': ['No'],
    'addepev2': ['No'],
    'employ1': ['Retired'],
    'weight2': [60],
    'height3': [150],
    'renthom1': ['Own'],
    'qlactlm2': ['No'],
    'diabete3': ['Yes'],
    'smoke100': ['Yes'],
    'asthma3': ['No'],
    'alcday5': [1],
    'sex': ['Male']
})

# Ensure that categorical columns are of type 'category' with the correct categories
categorical_columns = new_data.select_dtypes(include='category').columns
for col in categorical_columns:
    new_data[col] = pd.Categorical(new_data[col], categories=ordinal_encoder.mapping[col]['mapping'])

# Transform the new data using the loaded OrdinalEncoder
new_data_encoded = ordinal_encoder.transform(new_data)

# Define the list of chronic conditions and their corresponding model paths
chronic_conditions_models = [
    ('Heart Attack', '/content/heart_attack_model.pkl'),
    ('Angina Or Coronary Heart Disease', '/content/angina_or_coronary_heart_disease_model.pkl'),
    ('Stroke', '/content/stroke_model.pkl')
]

# Make predictions for each class
predictions = {}

for condition, model_filename in chronic_conditions_models:
    # Load the trained model
    loaded_model = joblib.load(model_filename)

    # Get the probability of the positive class (Yes)
    probability_yes = loaded_model.predict_proba(new_data_encoded)[:, 1][0]

    # Store the result
    predictions[condition] = probability_yes * 100

# Display the predictions for each chronic health condition
for condition, probability in predictions.items():
    print(f"There is {probability:.2f}% chance for {condition}")

"""**Sample Input 2**"""

# Load the saved OrdinalEncoder
encoder_filename = 'ordinal_encoder.pkl'
ordinal_encoder = joblib.load(encoder_filename)

# Prepare new input data
new_data = pd.DataFrame({
    'bphigh4': ['Yes'],
    'toldhi2': ['No'],
    'chcocncr': ['No'],
    'havarth3': ['No'],
    'addepev2': ['No'],
    'employ1': ['Retired'],
    'weight2': [60],
    'height3': [150],
    'renthom1': ['Own'],
    'qlactlm2': ['No'],
    'diabete3': ['Yes'],
    'smoke100': ['Yes'],
    'asthma3': ['Yes'],
    'alcday5': [4],
    'sex': ['Male']
})

# Ensure that categorical columns are of type 'category' with the correct categories
categorical_columns = new_data.select_dtypes(include='category').columns
for col in categorical_columns:
    new_data[col] = pd.Categorical(new_data[col], categories=ordinal_encoder.mapping[col]['mapping'])

# Transform the new data using the loaded OrdinalEncoder
new_data_encoded = ordinal_encoder.transform(new_data)

# Define the list of chronic conditions and their corresponding model paths
chronic_conditions_models = [
    ('Heart Attack', '/content/heart_attack_model.pkl'),
    ('Angina Or Coronary Heart Disease', '/content/angina_or_coronary_heart_disease_model.pkl'),
    ('Stroke', '/content/stroke_model.pkl')
]

# Make predictions for each class
predictions = {}

for condition, model_filename in chronic_conditions_models:
    # Load the trained model
    loaded_model = joblib.load(model_filename)

    # Get the probability of the positive class (Yes)
    probability_yes = loaded_model.predict_proba(new_data_encoded)[:, 1][0]

    # Store the result
    predictions[condition] = probability_yes * 100

# Display the predictions for each chronic health condition
for condition, probability in predictions.items():
    print(f"There is {probability:.2f}% chance for {condition}")